{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#quickstart","title":"Quickstart","text":"<p>Typical requests usage has falling into some anti-patterns.</p> <ul> <li>Being url-based, realistically all code needs to deal with url joining. Which tends to be redundant and suffer from leading or trailing slash issues.</li> <li>The module level methods don't take advantage of connection pooling, and require duplicate settings. Given the \"100% automatic\" documentation of connection reuse, it's unclear how widely known this is.</li> <li>Using a <code>Session</code> requires assigning every setting individually, and still requires url joining.</li> </ul> <p>Clients aim to be encourage best practices while still being convenient. Examples use the httpbin client testing service.</p> <pre><code>client = clients.Client(url, auth=('user', 'pass'), headers={'x-test': 'true'})\nr = client.get('headers', headers={'x-test2': 'true'})\nassert {'x-test', 'x-test2'} &lt;= set(r.request.headers)\n\nr = client.get('cookies')\nassert r.json() == {'cookies': {}}\n\nclient.get('cookies/set', params={'sessioncookie': '123456789'})\nr = client.get('cookies')\nassert r.json() == {'cookies': {'sessioncookie': '123456789'}}\n</code></pre> <p>Which reveals another anti-pattern regarding <code>Response</code> objects. Although the response object is sometimes required, naturally the most common use case is to access the content. But the onus is on the caller to check the <code>status_code</code> and <code>content-type</code>.</p> <p>Resources aim to making writing custom api clients or sdks easier. Their primary feature is to allow direct content access without silencing errors. Response content type is inferred from headers: <code>json</code>, <code>content</code>, or <code>text</code>.</p> <pre><code>resource = clients.Resource(url)\nassert resource.get('get')['url'] == url + '/get'\nwith pytest.raises(IOError):\n    resource.get('status/404')\nassert '&lt;html&gt;' in resource.get('html')\nassert isinstance(resource.get('bytes/10'), bytes)\n</code></pre>"},{"location":"#advanced-usage","title":"Advanced Usage","text":"<p><code>Clients</code> allow any base url, not just hosts, and consequently support path concatenation. Following the semantics of <code>urljoin</code> however, absolute paths and urls are treated as such. Hence there's no need to parse a url retrieved from an api.</p> <pre><code>client = clients.Client(url)\ncookies = client / 'cookies'\nassert isinstance(cookies, clients.Client)\nassert cookies.get().url == url + '/cookies'\n\nassert cookies.get('/').url == url + '/'\nassert cookies.get(url).url == url + '/'\n</code></pre> <p>Some api endpoints require trailing slashes; some forbid them. Set it and forget it.</p> <pre><code>client = clients.Client(url, trailing='/')\nassert client.get('ip').status_code == 404\n</code></pre> <p>Note <code>trailing</code> isn\\'t limited to only being a slash. This can be useful for static paths below a parameter: <code>api/v1/{query}.json</code>.</p>"},{"location":"#asyncio","title":"Asyncio","text":"<p>AsyncClients and AsyncResources implement the same interface, except the request methods return asyncio coroutines.</p>"},{"location":"#avant-garde-usage","title":"Avant-garde Usage","text":"<p><code>Resources</code> support operator overloaded syntax wherever sensible. These interfaces often obviate the need for writing custom clients specific to an API.</p> <ul> <li><code>__getattr__</code>: alternate path concatenation</li> <li><code>__getitem__</code>: GET content</li> <li><code>__setitem__</code>: PUT json</li> <li><code>__delitem__</code>: DELETE</li> <li><code>__contains__</code>: HEAD ok</li> <li><code>__iter__</code>: GET streamed lines or content</li> <li><code>__call__</code>: GET with params</li> </ul> <pre><code>resource = clients.Resource(url)\nassert set(resource['get']) == {'origin', 'headers', 'args', 'url'}\nresource['put'] = {}\ndel resource['delete']\n\nassert '200' in resource.status\nassert '404' not in resource.status\nassert [line['id'] for line in resource / 'stream/3'] == [0, 1, 2]\nassert next(iter(resource / 'html')) == '&lt;!DOCTYPE html&gt;'\nassert resource('cookies/set', name='value') == {'cookies': {'name': 'value'}}\n</code></pre> <p>Higher-level methods for common requests.</p> <ul> <li><code>iter</code>: __iter__ with args</li> <li><code>update</code>: PATCH with json params, or GET with conditional PUT</li> <li><code>create</code>: POST and return location</li> <li><code>download</code>: GET streamed content to file</li> <li><code>authorize</code>: acquire oauth token</li> </ul> <pre><code>resource = clients.Resource(url)\nassert list(map(len, resource.iter('stream-bytes/256'))) == [128] * 2\nassert resource.update('patch', name='value')['json'] == {'name': 'value'}\nassert resource.create('post', {'name': 'value'}) is None\nfile = resource.download(io.BytesIO(), 'image/png')\nassert file.tell()\n</code></pre> <p>A singleton decorator can be used on subclasses, conveniently creating a single custom instance.</p> <pre><code>@clients.singleton('http://localhost/')\nclass custom_api(clients.Resource):\n    pass  # custom methods\n\nassert isinstance(custom_api, clients.Resource)\nassert custom_api.url == 'http://localhost/'\n</code></pre> <p>Remote and AsyncRemote clients default to POSTs with json bodies, for APIs which are more RPC than REST.</p> <p>Graph and AsyncGraph remote clients execute GraphQL queries.</p> <p>Proxy and AsyncProxy clients provide load-balancing across multiple hosts, with an extensible interface for different algorithms.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#clients.base.BaseClient","title":"<code>clients.base.BaseClient</code>","text":"<p>Client mixin.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>base url for requests</p> required <code>trailing</code> <code>str</code> <p>trailing chars (e.g. /) appended to the url</p> <code>''</code> <code>**attrs</code> <p>additional Session attributes</p> <code>{}</code> Source code in <code>clients/base.py</code> <pre><code>class BaseClient:\n    \"\"\"Client mixin.\n\n    Args:\n        url: base url for requests\n        trailing: trailing chars (e.g. /) appended to the url\n        **attrs: additional Session attributes\n    \"\"\"\n\n    def __init__(self, url: str, *, trailing: str = '', **attrs):\n        super().__init__(base_url=url.rstrip('/') + '/', **attrs)  # type: ignore\n        self._attrs = attrs\n        self.trailing = trailing\n\n    def __repr__(self):\n        return f'{type(self).__name__}({self.url}... {self.trailing})'\n\n    def __truediv__(self, path: str) -&gt; Client:\n        \"\"\"Return a cloned client with appended path.\"\"\"\n        return type(self).clone(self, path)\n\n    @property\n    def url(self):\n        return str(self.base_url)\n\n    @classmethod\n    def clone(cls, other, path='', **kwargs):\n        url = str(other.base_url.join(path))\n        return cls(url, trailing=other.trailing, **(other._attrs | kwargs))\n\n    def request(self, method, path, **kwargs):\n        \"\"\"Send request with relative or absolute path and return response.\"\"\"\n        url = str(self.base_url.join(path)).rstrip('/') + self.trailing  # type: ignore\n        return super().request(method, url, **kwargs)  # type: ignore\n\n    def get(self, path='', **kwargs):\n        \"\"\"GET request with optional path.\"\"\"\n        return self.request('GET', path, **kwargs)\n\n    def options(self, path='', **kwargs):\n        \"\"\"OPTIONS request with optional path.\"\"\"\n        return self.request('OPTIONS', path, **kwargs)\n\n    def head(self, path='', **kwargs):\n        \"\"\"HEAD request with optional path.\"\"\"\n        return self.request('HEAD', path, **kwargs)\n\n    def post(self, path='', json=None, **kwargs):\n        \"\"\"POST request with optional path and json body.\"\"\"\n        return self.request('POST', path, json=json, **kwargs)\n\n    def put(self, path='', json=None, **kwargs):\n        \"\"\"PUT request with optional path and json body.\"\"\"\n        return self.request('PUT', path, json=json, **kwargs)\n\n    def patch(self, path='', json=None, **kwargs):\n        \"\"\"PATCH request with optional path and json body.\"\"\"\n        return self.request('PATCH', path, json=json, **kwargs)\n\n    def delete(self, path='', **kwargs):\n        \"\"\"DELETE request with optional path.\"\"\"\n        return self.request('DELETE', path, **kwargs)\n</code></pre>"},{"location":"reference/#clients.base.BaseClient.__truediv__","title":"<code>__truediv__(path)</code>","text":"<p>Return a cloned client with appended path.</p> Source code in <code>clients/base.py</code> <pre><code>def __truediv__(self, path: str) -&gt; Client:\n    \"\"\"Return a cloned client with appended path.\"\"\"\n    return type(self).clone(self, path)\n</code></pre>"},{"location":"reference/#clients.base.BaseClient.delete","title":"<code>delete(path='', **kwargs)</code>","text":"<p>DELETE request with optional path.</p> Source code in <code>clients/base.py</code> <pre><code>def delete(self, path='', **kwargs):\n    \"\"\"DELETE request with optional path.\"\"\"\n    return self.request('DELETE', path, **kwargs)\n</code></pre>"},{"location":"reference/#clients.base.BaseClient.get","title":"<code>get(path='', **kwargs)</code>","text":"<p>GET request with optional path.</p> Source code in <code>clients/base.py</code> <pre><code>def get(self, path='', **kwargs):\n    \"\"\"GET request with optional path.\"\"\"\n    return self.request('GET', path, **kwargs)\n</code></pre>"},{"location":"reference/#clients.base.BaseClient.head","title":"<code>head(path='', **kwargs)</code>","text":"<p>HEAD request with optional path.</p> Source code in <code>clients/base.py</code> <pre><code>def head(self, path='', **kwargs):\n    \"\"\"HEAD request with optional path.\"\"\"\n    return self.request('HEAD', path, **kwargs)\n</code></pre>"},{"location":"reference/#clients.base.BaseClient.options","title":"<code>options(path='', **kwargs)</code>","text":"<p>OPTIONS request with optional path.</p> Source code in <code>clients/base.py</code> <pre><code>def options(self, path='', **kwargs):\n    \"\"\"OPTIONS request with optional path.\"\"\"\n    return self.request('OPTIONS', path, **kwargs)\n</code></pre>"},{"location":"reference/#clients.base.BaseClient.patch","title":"<code>patch(path='', json=None, **kwargs)</code>","text":"<p>PATCH request with optional path and json body.</p> Source code in <code>clients/base.py</code> <pre><code>def patch(self, path='', json=None, **kwargs):\n    \"\"\"PATCH request with optional path and json body.\"\"\"\n    return self.request('PATCH', path, json=json, **kwargs)\n</code></pre>"},{"location":"reference/#clients.base.BaseClient.post","title":"<code>post(path='', json=None, **kwargs)</code>","text":"<p>POST request with optional path and json body.</p> Source code in <code>clients/base.py</code> <pre><code>def post(self, path='', json=None, **kwargs):\n    \"\"\"POST request with optional path and json body.\"\"\"\n    return self.request('POST', path, json=json, **kwargs)\n</code></pre>"},{"location":"reference/#clients.base.BaseClient.put","title":"<code>put(path='', json=None, **kwargs)</code>","text":"<p>PUT request with optional path and json body.</p> Source code in <code>clients/base.py</code> <pre><code>def put(self, path='', json=None, **kwargs):\n    \"\"\"PUT request with optional path and json body.\"\"\"\n    return self.request('PUT', path, json=json, **kwargs)\n</code></pre>"},{"location":"reference/#clients.base.BaseClient.request","title":"<code>request(method, path, **kwargs)</code>","text":"<p>Send request with relative or absolute path and return response.</p> Source code in <code>clients/base.py</code> <pre><code>def request(self, method, path, **kwargs):\n    \"\"\"Send request with relative or absolute path and return response.\"\"\"\n    url = str(self.base_url.join(path)).rstrip('/') + self.trailing  # type: ignore\n    return super().request(method, url, **kwargs)  # type: ignore\n</code></pre>"},{"location":"reference/#clients.Client","title":"<code>clients.Client</code>","text":"<p>               Bases: <code>BaseClient</code>, <code>Client</code></p> Source code in <code>clients/base.py</code> <pre><code>class Client(BaseClient, httpx.Client):\n    def stream(self, method, path, **kwargs):\n        \"\"\"Send request with relative or absolute path and stream response.\"\"\"\n        url = str(self.base_url.join(path)).rstrip('/') + self.trailing\n        return super().stream(method, url, **kwargs)\n</code></pre>"},{"location":"reference/#clients.Client.stream","title":"<code>stream(method, path, **kwargs)</code>","text":"<p>Send request with relative or absolute path and stream response.</p> Source code in <code>clients/base.py</code> <pre><code>def stream(self, method, path, **kwargs):\n    \"\"\"Send request with relative or absolute path and stream response.\"\"\"\n    url = str(self.base_url.join(path)).rstrip('/') + self.trailing\n    return super().stream(method, url, **kwargs)\n</code></pre>"},{"location":"reference/#clients.Resource","title":"<code>clients.Resource</code>","text":"<p>               Bases: <code>Client</code></p> <p>A <code>Client</code> which returns json content and has syntactic support for requests.</p> Source code in <code>clients/base.py</code> <pre><code>class Resource(Client):\n    \"\"\"A `Client` which returns json content and has syntactic support for requests.\"\"\"\n\n    client = property(Client.clone, doc=\"upcasted `Client`\")\n    __getitem__ = Client.get\n    __setitem__ = Client.put\n    __delitem__ = Client.delete\n    __getattr__ = Client.__truediv__\n    content_type = staticmethod(\n        functools.partial(content_type, text='text/', json=r'application/(\\w|\\.)*\\+?json')\n    )\n\n    def request(self, method, path, **kwargs):\n        \"\"\"Send request with path and return processed content.\"\"\"\n        response = super().request(method, path, **kwargs).raise_for_status()\n        match self.content_type(response):\n            case 'json':\n                return response.json()\n            case 'text':\n                return response.text\n        return response.content\n\n    def stream(self, method: str = 'GET', path: str = '', **kwargs) -&gt; Iterator:\n        \"\"\"Iterate lines or chunks from streamed request.\"\"\"\n        with super().stream(method, path, **kwargs) as response:\n            match self.content_type(response.raise_for_status()):\n                case 'json':\n                    yield from map(json.loads, response.iter_lines())\n                case 'text':\n                    yield from response.iter_lines()\n                case _:\n                    yield from response.iter_bytes()\n\n    __iter__ = stream\n\n    def __contains__(self, path: str):\n        \"\"\"Return whether endpoint exists according to HEAD request.\"\"\"\n        return not super().request('HEAD', path).is_error\n\n    def __call__(self, path: str = '', **params):\n        \"\"\"GET request with params.\"\"\"\n        return self.get(path, params=params)\n\n    def updater(self, path='', **kwargs):\n        response = super().request('GET', path, **kwargs).raise_for_status()\n        kwargs['headers'] = dict(kwargs.get('headers', {}), **validate(response))\n        yield self.put(path, (yield response.json()), **kwargs)\n\n    @contextlib.contextmanager\n    def updating(self, path: str = '', **kwargs):\n        \"\"\"Context manager to GET and conditionally PUT json data.\"\"\"\n        updater = self.updater(path, **kwargs)\n        json = next(updater)\n        yield json\n        updater.send(json)\n\n    def update(self, path: str = '', callback: Callable | None = None, **json):\n        \"\"\"PATCH request with json params.\n\n        Args:\n            callback: optionally update with GET and validated PUT.\n                `callback` is called on the json result with keyword params, i.e.,\n                `dict` correctly implements the simple update case.\n        \"\"\"\n        if callback is None:\n            return self.patch(path, json=json)\n        updater = self.updater(path)\n        return updater.send(callback(next(updater), **json))\n\n    def create(self, path: str = '', json=None, **kwargs) -&gt; str:\n        \"\"\"POST request and return location.\"\"\"\n        response = super().request('POST', path, json=json, **kwargs).raise_for_status()\n        return response.headers.get('location')\n\n    def download(self, file, path: str = '', **kwargs):\n        \"\"\"Output streamed GET request to file.\"\"\"\n        for chunk in self.stream(path=path, **kwargs):\n            file.write(chunk)\n        return file\n\n    def authorize(self, path: str = '', **kwargs) -&gt; dict:\n        \"\"\"Acquire oauth access token and set `Authorization` header.\"\"\"\n        method = 'GET' if {'json', 'data'}.isdisjoint(kwargs) else 'POST'\n        result = self.request(method, path, **kwargs)\n        self.headers['authorization'] = f\"{result['token_type']} {result['access_token']}\"\n        return result\n</code></pre>"},{"location":"reference/#clients.Resource.__call__","title":"<code>__call__(path='', **params)</code>","text":"<p>GET request with params.</p> Source code in <code>clients/base.py</code> <pre><code>def __call__(self, path: str = '', **params):\n    \"\"\"GET request with params.\"\"\"\n    return self.get(path, params=params)\n</code></pre>"},{"location":"reference/#clients.Resource.__contains__","title":"<code>__contains__(path)</code>","text":"<p>Return whether endpoint exists according to HEAD request.</p> Source code in <code>clients/base.py</code> <pre><code>def __contains__(self, path: str):\n    \"\"\"Return whether endpoint exists according to HEAD request.\"\"\"\n    return not super().request('HEAD', path).is_error\n</code></pre>"},{"location":"reference/#clients.Resource.authorize","title":"<code>authorize(path='', **kwargs)</code>","text":"<p>Acquire oauth access token and set <code>Authorization</code> header.</p> Source code in <code>clients/base.py</code> <pre><code>def authorize(self, path: str = '', **kwargs) -&gt; dict:\n    \"\"\"Acquire oauth access token and set `Authorization` header.\"\"\"\n    method = 'GET' if {'json', 'data'}.isdisjoint(kwargs) else 'POST'\n    result = self.request(method, path, **kwargs)\n    self.headers['authorization'] = f\"{result['token_type']} {result['access_token']}\"\n    return result\n</code></pre>"},{"location":"reference/#clients.Resource.create","title":"<code>create(path='', json=None, **kwargs)</code>","text":"<p>POST request and return location.</p> Source code in <code>clients/base.py</code> <pre><code>def create(self, path: str = '', json=None, **kwargs) -&gt; str:\n    \"\"\"POST request and return location.\"\"\"\n    response = super().request('POST', path, json=json, **kwargs).raise_for_status()\n    return response.headers.get('location')\n</code></pre>"},{"location":"reference/#clients.Resource.download","title":"<code>download(file, path='', **kwargs)</code>","text":"<p>Output streamed GET request to file.</p> Source code in <code>clients/base.py</code> <pre><code>def download(self, file, path: str = '', **kwargs):\n    \"\"\"Output streamed GET request to file.\"\"\"\n    for chunk in self.stream(path=path, **kwargs):\n        file.write(chunk)\n    return file\n</code></pre>"},{"location":"reference/#clients.Resource.request","title":"<code>request(method, path, **kwargs)</code>","text":"<p>Send request with path and return processed content.</p> Source code in <code>clients/base.py</code> <pre><code>def request(self, method, path, **kwargs):\n    \"\"\"Send request with path and return processed content.\"\"\"\n    response = super().request(method, path, **kwargs).raise_for_status()\n    match self.content_type(response):\n        case 'json':\n            return response.json()\n        case 'text':\n            return response.text\n    return response.content\n</code></pre>"},{"location":"reference/#clients.Resource.stream","title":"<code>stream(method='GET', path='', **kwargs)</code>","text":"<p>Iterate lines or chunks from streamed request.</p> Source code in <code>clients/base.py</code> <pre><code>def stream(self, method: str = 'GET', path: str = '', **kwargs) -&gt; Iterator:\n    \"\"\"Iterate lines or chunks from streamed request.\"\"\"\n    with super().stream(method, path, **kwargs) as response:\n        match self.content_type(response.raise_for_status()):\n            case 'json':\n                yield from map(json.loads, response.iter_lines())\n            case 'text':\n                yield from response.iter_lines()\n            case _:\n                yield from response.iter_bytes()\n</code></pre>"},{"location":"reference/#clients.Resource.update","title":"<code>update(path='', callback=None, **json)</code>","text":"<p>PATCH request with json params.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable | None</code> <p>optionally update with GET and validated PUT. <code>callback</code> is called on the json result with keyword params, i.e., <code>dict</code> correctly implements the simple update case.</p> <code>None</code> Source code in <code>clients/base.py</code> <pre><code>def update(self, path: str = '', callback: Callable | None = None, **json):\n    \"\"\"PATCH request with json params.\n\n    Args:\n        callback: optionally update with GET and validated PUT.\n            `callback` is called on the json result with keyword params, i.e.,\n            `dict` correctly implements the simple update case.\n    \"\"\"\n    if callback is None:\n        return self.patch(path, json=json)\n    updater = self.updater(path)\n    return updater.send(callback(next(updater), **json))\n</code></pre>"},{"location":"reference/#clients.Resource.updating","title":"<code>updating(path='', **kwargs)</code>","text":"<p>Context manager to GET and conditionally PUT json data.</p> Source code in <code>clients/base.py</code> <pre><code>@contextlib.contextmanager\ndef updating(self, path: str = '', **kwargs):\n    \"\"\"Context manager to GET and conditionally PUT json data.\"\"\"\n    updater = self.updater(path, **kwargs)\n    json = next(updater)\n    yield json\n    updater.send(json)\n</code></pre>"},{"location":"reference/#clients.Remote","title":"<code>clients.Remote</code>","text":"<p>               Bases: <code>Client</code></p> <p>A <code>Client</code> which defaults to posts with json bodies, i.e., RPC.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>base url for requests</p> required <code>json</code> <code>Mapping</code> <p>default json body for all calls</p> <code>{}</code> <code>**kwargs</code> <p>same options as <code>Client</code></p> <code>{}</code> Source code in <code>clients/base.py</code> <pre><code>class Remote(Client):\n    \"\"\"A `Client` which defaults to posts with json bodies, i.e., RPC.\n\n    Args:\n        url: base url for requests\n        json: default json body for all calls\n        **kwargs: same options as `Client`\n    \"\"\"\n\n    client = Resource.client\n    __getattr__ = Resource.__getattr__\n\n    def __init__(self, url: str, json: Mapping = {}, **kwargs):\n        super().__init__(url, **kwargs)\n        self.json = dict(json)\n\n    @classmethod\n    def clone(cls, other, path=''):\n        return Client.clone.__func__(cls, other, path, json=other.json)\n\n    def __call__(self, path: str = '', **json):\n        \"\"\"POST request with json body and [check][clients.base.Remote.check] result.\"\"\"\n        response = self.post(path, json=dict(self.json, **json)).raise_for_status()\n        return self.check(response.json())\n\n    @staticmethod\n    def check(result):\n        \"\"\"Override to return result or raise error, for APIs which don't use status codes.\"\"\"\n        return result\n</code></pre>"},{"location":"reference/#clients.Remote.__call__","title":"<code>__call__(path='', **json)</code>","text":"<p>POST request with json body and check result.</p> Source code in <code>clients/base.py</code> <pre><code>def __call__(self, path: str = '', **json):\n    \"\"\"POST request with json body and [check][clients.base.Remote.check] result.\"\"\"\n    response = self.post(path, json=dict(self.json, **json)).raise_for_status()\n    return self.check(response.json())\n</code></pre>"},{"location":"reference/#clients.Remote.check","title":"<code>check(result)</code>  <code>staticmethod</code>","text":"<p>Override to return result or raise error, for APIs which don't use status codes.</p> Source code in <code>clients/base.py</code> <pre><code>@staticmethod\ndef check(result):\n    \"\"\"Override to return result or raise error, for APIs which don't use status codes.\"\"\"\n    return result\n</code></pre>"},{"location":"reference/#clients.Graph","title":"<code>clients.Graph</code>","text":"<p>               Bases: <code>Remote</code></p> <p>A <code>Remote</code> client which executes GraphQL queries.</p> Source code in <code>clients/base.py</code> <pre><code>class Graph(Remote):\n    \"\"\"A `Remote` client which executes GraphQL queries.\"\"\"\n\n    Error = ValueError\n\n    @classmethod\n    def check(cls, result: dict):\n        \"\"\"Return `data` or raise `errors`.\"\"\"\n        for error in result.get('errors', ()):\n            raise cls.Error(error)\n        return result.get('data')\n\n    def execute(self, query: str, **variables):\n        \"\"\"Execute query over POST.\"\"\"\n        return self(query=query, variables=variables)\n</code></pre>"},{"location":"reference/#clients.Graph.check","title":"<code>check(result)</code>  <code>classmethod</code>","text":"<p>Return <code>data</code> or raise <code>errors</code>.</p> Source code in <code>clients/base.py</code> <pre><code>@classmethod\ndef check(cls, result: dict):\n    \"\"\"Return `data` or raise `errors`.\"\"\"\n    for error in result.get('errors', ()):\n        raise cls.Error(error)\n    return result.get('data')\n</code></pre>"},{"location":"reference/#clients.Graph.execute","title":"<code>execute(query, **variables)</code>","text":"<p>Execute query over POST.</p> Source code in <code>clients/base.py</code> <pre><code>def execute(self, query: str, **variables):\n    \"\"\"Execute query over POST.\"\"\"\n    return self(query=query, variables=variables)\n</code></pre>"},{"location":"reference/#clients.Proxy","title":"<code>clients.Proxy</code>","text":"<p>               Bases: <code>Client</code></p> <p>An extensible embedded proxy client to multiple hosts.</p> <p>The default implementation provides load balancing based on active connections. It does not provide error handling or retrying.</p> <p>Parameters:</p> Name Type Description Default <code>*urls</code> <code>str</code> <p>base urls for requests</p> <code>()</code> <code>**kwargs</code> <p>same options as <code>Client</code></p> <code>{}</code> Source code in <code>clients/base.py</code> <pre><code>class Proxy(Client):\n    \"\"\"An extensible embedded proxy client to multiple hosts.\n\n    The default implementation provides load balancing based on active connections.\n    It does not provide error handling or retrying.\n\n    Args:\n        *urls: base urls for requests\n        **kwargs: same options as `Client`\n    \"\"\"\n\n    Stats = Stats\n\n    def __init__(self, *urls: str, **kwargs):\n        super().__init__('https://proxies', **kwargs)\n        self.urls = {(url.rstrip('/') + '/'): self.Stats() for url in urls}\n\n    @classmethod\n    def clone(cls, other, path=''):\n        urls = (urljoin(url, path) for url in other.urls)\n        return cls(*urls, trailing=other.trailing, **other._attrs)\n\n    def priority(self, url: str):\n        \"\"\"Return comparable priority for url.\n\n        Minimizes errors, failures (500s), and active connections.\n        None may be used to eliminate from consideration.\n        \"\"\"\n        stats = self.urls[url]\n        return tuple(stats[key] for key in ('errors', 'failures', 'connections'))\n\n    def choice(self, method: str) -&gt; str:\n        \"\"\"Return chosen url according to priority.\n\n        Args:\n            method: placeholder for extensions which distinguish read/write requests\n        \"\"\"\n        priorities = collections.defaultdict(list)\n        for url in self.urls:\n            priorities[self.priority(url)].append(url)\n        priorities.pop(None, None)\n        return random.choice(priorities[min(priorities)])\n\n    def request(self, method, path, **kwargs):\n        \"\"\"Send request with relative or absolute path and return response.\"\"\"\n        url = self.choice(method)\n        with self.urls[url] as stats:\n            response = super().request(method, urljoin(url, path), **kwargs)\n        stats.add(failures=int(response.is_server_error))\n        return response\n</code></pre>"},{"location":"reference/#clients.Proxy.choice","title":"<code>choice(method)</code>","text":"<p>Return chosen url according to priority.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>placeholder for extensions which distinguish read/write requests</p> required Source code in <code>clients/base.py</code> <pre><code>def choice(self, method: str) -&gt; str:\n    \"\"\"Return chosen url according to priority.\n\n    Args:\n        method: placeholder for extensions which distinguish read/write requests\n    \"\"\"\n    priorities = collections.defaultdict(list)\n    for url in self.urls:\n        priorities[self.priority(url)].append(url)\n    priorities.pop(None, None)\n    return random.choice(priorities[min(priorities)])\n</code></pre>"},{"location":"reference/#clients.Proxy.priority","title":"<code>priority(url)</code>","text":"<p>Return comparable priority for url.</p> <p>Minimizes errors, failures (500s), and active connections. None may be used to eliminate from consideration.</p> Source code in <code>clients/base.py</code> <pre><code>def priority(self, url: str):\n    \"\"\"Return comparable priority for url.\n\n    Minimizes errors, failures (500s), and active connections.\n    None may be used to eliminate from consideration.\n    \"\"\"\n    stats = self.urls[url]\n    return tuple(stats[key] for key in ('errors', 'failures', 'connections'))\n</code></pre>"},{"location":"reference/#clients.Proxy.request","title":"<code>request(method, path, **kwargs)</code>","text":"<p>Send request with relative or absolute path and return response.</p> Source code in <code>clients/base.py</code> <pre><code>def request(self, method, path, **kwargs):\n    \"\"\"Send request with relative or absolute path and return response.\"\"\"\n    url = self.choice(method)\n    with self.urls[url] as stats:\n        response = super().request(method, urljoin(url, path), **kwargs)\n    stats.add(failures=int(response.is_server_error))\n    return response\n</code></pre>"},{"location":"reference/#clients.AsyncClient","title":"<code>clients.AsyncClient</code>","text":"<p>               Bases: <code>BaseClient</code>, <code>AsyncClient</code></p> Source code in <code>clients/aio.py</code> <pre><code>class AsyncClient(BaseClient, httpx.AsyncClient):\n    def run(self, name: str, *args, **kwargs):\n        \"\"\"Synchronously call method and run coroutine.\"\"\"\n        return asyncio.new_event_loop().run_until_complete(getattr(self, name)(*args, **kwargs))\n</code></pre>"},{"location":"reference/#clients.AsyncClient.run","title":"<code>run(name, *args, **kwargs)</code>","text":"<p>Synchronously call method and run coroutine.</p> Source code in <code>clients/aio.py</code> <pre><code>def run(self, name: str, *args, **kwargs):\n    \"\"\"Synchronously call method and run coroutine.\"\"\"\n    return asyncio.new_event_loop().run_until_complete(getattr(self, name)(*args, **kwargs))\n</code></pre>"},{"location":"reference/#clients.AsyncResource","title":"<code>clients.AsyncResource</code>","text":"<p>               Bases: <code>AsyncClient</code></p> <p>An <code>AsyncClient</code> which returns json content and has syntactic support for requests.</p> Source code in <code>clients/aio.py</code> <pre><code>class AsyncResource(AsyncClient):\n    \"\"\"An `AsyncClient` which returns json content and has syntactic support for requests.\"\"\"\n\n    client = property(AsyncClient.clone, doc=\"upcasted `AsyncClient`\")\n    __getattr__ = AsyncClient.__truediv__\n    __getitem__ = AsyncClient.get\n    content_type = staticmethod(Resource.content_type)\n    __call__ = Resource.__call__\n\n    async def request(self, method, path, **kwargs):\n        \"\"\"Send request with path and return processed content.\"\"\"\n        response = (await super().request(method, path, **kwargs)).raise_for_status()\n        match self.content_type(response):\n            case 'json':\n                return response.json()\n            case 'text':\n                return response.text\n        return response.content\n\n    async def updater(self, path='', **kwargs):\n        response = (await super().request('GET', path, **kwargs)).raise_for_status()\n        kwargs['headers'] = dict(kwargs.get('headers', {}), **validate(response))\n        yield await self.put(path, (yield response.json()), **kwargs)\n\n    @contextlib.asynccontextmanager\n    async def updating(self, path: str = '', **kwargs):\n        \"\"\"Context manager to GET and conditionally PUT json data.\"\"\"\n        updater = self.updater(path, **kwargs)\n        json = await updater.__anext__()\n        yield json\n        await updater.asend(json)\n\n    async def update(self, path: str = '', callback: Callable | None = None, **json):\n        \"\"\"PATCH request with json params.\n\n        Args:\n            callback: optionally update with GET and validated PUT.\n                `callback` is called on the json result with keyword params, i.e.,\n                `dict` correctly implements the simple update case.\n        \"\"\"\n        if callback is None:\n            return await self.patch(path, json)\n        updater = self.updater(path)\n        return await updater.asend(callback(await updater.__anext__(), **json))\n\n    async def authorize(self, path: str = '', **kwargs) -&gt; dict:\n        \"\"\"Acquire oauth access token and set `Authorization` header.\"\"\"\n        method = 'GET' if {'json', 'data'}.isdisjoint(kwargs) else 'POST'\n        result = await self.request(method, path, **kwargs)\n        self.headers['authorization'] = f\"{result['token_type']} {result['access_token']}\"\n        self._attrs['headers'] = self.headers\n        return result\n</code></pre>"},{"location":"reference/#clients.AsyncResource.authorize","title":"<code>authorize(path='', **kwargs)</code>  <code>async</code>","text":"<p>Acquire oauth access token and set <code>Authorization</code> header.</p> Source code in <code>clients/aio.py</code> <pre><code>async def authorize(self, path: str = '', **kwargs) -&gt; dict:\n    \"\"\"Acquire oauth access token and set `Authorization` header.\"\"\"\n    method = 'GET' if {'json', 'data'}.isdisjoint(kwargs) else 'POST'\n    result = await self.request(method, path, **kwargs)\n    self.headers['authorization'] = f\"{result['token_type']} {result['access_token']}\"\n    self._attrs['headers'] = self.headers\n    return result\n</code></pre>"},{"location":"reference/#clients.AsyncResource.request","title":"<code>request(method, path, **kwargs)</code>  <code>async</code>","text":"<p>Send request with path and return processed content.</p> Source code in <code>clients/aio.py</code> <pre><code>async def request(self, method, path, **kwargs):\n    \"\"\"Send request with path and return processed content.\"\"\"\n    response = (await super().request(method, path, **kwargs)).raise_for_status()\n    match self.content_type(response):\n        case 'json':\n            return response.json()\n        case 'text':\n            return response.text\n    return response.content\n</code></pre>"},{"location":"reference/#clients.AsyncResource.update","title":"<code>update(path='', callback=None, **json)</code>  <code>async</code>","text":"<p>PATCH request with json params.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable | None</code> <p>optionally update with GET and validated PUT. <code>callback</code> is called on the json result with keyword params, i.e., <code>dict</code> correctly implements the simple update case.</p> <code>None</code> Source code in <code>clients/aio.py</code> <pre><code>async def update(self, path: str = '', callback: Callable | None = None, **json):\n    \"\"\"PATCH request with json params.\n\n    Args:\n        callback: optionally update with GET and validated PUT.\n            `callback` is called on the json result with keyword params, i.e.,\n            `dict` correctly implements the simple update case.\n    \"\"\"\n    if callback is None:\n        return await self.patch(path, json)\n    updater = self.updater(path)\n    return await updater.asend(callback(await updater.__anext__(), **json))\n</code></pre>"},{"location":"reference/#clients.AsyncResource.updating","title":"<code>updating(path='', **kwargs)</code>  <code>async</code>","text":"<p>Context manager to GET and conditionally PUT json data.</p> Source code in <code>clients/aio.py</code> <pre><code>@contextlib.asynccontextmanager\nasync def updating(self, path: str = '', **kwargs):\n    \"\"\"Context manager to GET and conditionally PUT json data.\"\"\"\n    updater = self.updater(path, **kwargs)\n    json = await updater.__anext__()\n    yield json\n    await updater.asend(json)\n</code></pre>"},{"location":"reference/#clients.AsyncRemote","title":"<code>clients.AsyncRemote</code>","text":"<p>               Bases: <code>AsyncClient</code></p> <p>An <code>AsyncClient</code> which defaults to posts with json bodies, i.e., RPC.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>base url for requests</p> required <code>json</code> <code>Mapping</code> <p>default json body for all calls</p> <code>{}</code> <code>**kwargs</code> <p>same options as <code>AsyncClient</code></p> <code>{}</code> Source code in <code>clients/aio.py</code> <pre><code>class AsyncRemote(AsyncClient):\n    \"\"\"An `AsyncClient` which defaults to posts with json bodies, i.e., RPC.\n\n    Args:\n        url: base url for requests\n        json: default json body for all calls\n        **kwargs: same options as `AsyncClient`\n    \"\"\"\n\n    client = AsyncResource.client\n    __getattr__ = AsyncResource.__getattr__\n    check = staticmethod(Remote.check)\n\n    def __init__(self, url: str, json: Mapping = {}, **kwargs):\n        super().__init__(url, **kwargs)\n        self.json = dict(json)\n\n    @classmethod\n    def clone(cls, other, path=''):\n        return AsyncClient.clone.__func__(cls, other, path, json=other.json)\n\n    async def __call__(self, path='', **json):\n        \"\"\"POST request with json body and check result.\"\"\"\n        response = (await self.post(path, json=dict(self.json, **json))).raise_for_status()\n        return self.check(response.json())\n</code></pre>"},{"location":"reference/#clients.AsyncRemote.__call__","title":"<code>__call__(path='', **json)</code>  <code>async</code>","text":"<p>POST request with json body and check result.</p> Source code in <code>clients/aio.py</code> <pre><code>async def __call__(self, path='', **json):\n    \"\"\"POST request with json body and check result.\"\"\"\n    response = (await self.post(path, json=dict(self.json, **json))).raise_for_status()\n    return self.check(response.json())\n</code></pre>"},{"location":"reference/#clients.AsyncGraph","title":"<code>clients.AsyncGraph</code>","text":"<p>               Bases: <code>AsyncRemote</code></p> <p>An <code>AsyncRemote</code> client which executes GraphQL queries.</p> Source code in <code>clients/aio.py</code> <pre><code>class AsyncGraph(AsyncRemote):\n    \"\"\"An `AsyncRemote` client which executes GraphQL queries.\"\"\"\n\n    Error = httpx.HTTPError\n    execute = Graph.execute\n    check = classmethod(Graph.check.__func__)\n</code></pre>"},{"location":"reference/#clients.AsyncProxy","title":"<code>clients.AsyncProxy</code>","text":"<p>               Bases: <code>AsyncClient</code></p> <p>An extensible embedded proxy client to multiple hosts.</p> <p>The default implementation provides load balancing based on active connections. It does not provide error handling or retrying.</p> <p>Parameters:</p> Name Type Description Default <code>*urls</code> <code>str</code> <p>base urls for requests</p> <code>()</code> <code>**kwargs</code> <p>same options as <code>AsyncClient</code></p> <code>{}</code> Source code in <code>clients/aio.py</code> <pre><code>class AsyncProxy(AsyncClient):\n    \"\"\"An extensible embedded proxy client to multiple hosts.\n\n    The default implementation provides load balancing based on active connections.\n    It does not provide error handling or retrying.\n\n    Args:\n        *urls: base urls for requests\n        **kwargs: same options as `AsyncClient`\n    \"\"\"\n\n    Stats = Proxy.Stats\n    priority = Proxy.priority\n    choice = Proxy.choice\n\n    def __init__(self, *urls: str, **kwargs):\n        super().__init__('https://proxies', **kwargs)\n        self.urls = {(url.rstrip('/') + '/'): self.Stats() for url in urls}\n\n    @classmethod\n    def clone(cls, other, path=''):\n        urls = (urljoin(url, path) for url in other.urls)\n        return cls(*urls, trailing=other.trailing, **other._attrs)\n\n    async def request(self, method, path, **kwargs):\n        \"\"\"Send request with relative or absolute path and return response.\"\"\"\n        url = self.choice(method)  # type: ignore\n        with self.urls[url] as stats:\n            response = await super().request(method, urljoin(url, path), **kwargs)\n        stats.add(failures=int(response.status_code &gt;= 500))\n        return response\n</code></pre>"},{"location":"reference/#clients.AsyncProxy.request","title":"<code>request(method, path, **kwargs)</code>  <code>async</code>","text":"<p>Send request with relative or absolute path and return response.</p> Source code in <code>clients/aio.py</code> <pre><code>async def request(self, method, path, **kwargs):\n    \"\"\"Send request with relative or absolute path and return response.\"\"\"\n    url = self.choice(method)  # type: ignore\n    with self.urls[url] as stats:\n        response = await super().request(method, urljoin(url, path), **kwargs)\n    stats.add(failures=int(response.status_code &gt;= 500))\n    return response\n</code></pre>"},{"location":"reference/#clients.singleton","title":"<code>clients.singleton(*args, **kwargs)</code>","text":"<p>Return a decorator for singleton class instances.</p> Source code in <code>clients/__init__.py</code> <pre><code>def singleton(*args, **kwargs):\n    \"\"\"Return a decorator for singleton class instances.\"\"\"\n    return lambda cls: cls(*args, **kwargs)\n</code></pre>"}]}